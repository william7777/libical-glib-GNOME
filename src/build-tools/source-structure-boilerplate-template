struct _${upperCamel}Private {
        $^!${isBare}GObject *owner;
	^$${native} *native;$^${isPossibleGlobal}
        gboolean is_global_memory;^$
};

G_DEFINE_TYPE (${upperCamel}, ${lowerSnake}, G_TYPE_OBJECT)

enum {
	PROP_0,$^!${isBare}
        PROP_OWNER,^$
        PROP_NATIVE,$^${isPossibleGlobal}
        PROP_IS_GLOBAL_MEMORY^$
};$^!${isBare}

static ${set_owner}
{
	g_return_if_fail (object != NULL);
        if (owner != NULL) {
                object->priv->owner = g_object_ref (owner);
        } else {
                object->priv->owner = NULL;
        }
}^$

static ${set_native}
{
	g_return_if_fail (object != NULL);
	object->priv->native = (${native} *)native;
}
$^${isPossibleGlobal}
static ${set_is_global}
{
	g_return_if_fail (object != NULL);
	object->priv->is_global_memory = is_global_memory;
}^$

static ${set_property}
{
	${upperCamel} *self = ${upperSnake} (object);

	switch (property_id) {$^!${isBare}
		case PROP_OWNER:
			${lowerSnake}_set_owner (self, g_value_get_object (value));
			return;^$
		case PROP_NATIVE:
			${lowerSnake}_set_native (self, g_value_get_pointer (value));
			return;$^${isPossibleGlobal}
		case PROP_IS_GLOBAL_MEMORY:
			${lowerSnake}_set_is_global (self, g_value_get_boolean (value));
			return;^$
	}

	G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);	
}

static ${get_property}
{
	${upperCamel}Private *priv = ${upperSnake} (object)->priv;

	switch (property_id) {$^!${isBare}
		case PROP_OWNER:
			g_value_set_object (value, priv->owner);
			return;^$
		case PROP_NATIVE:
			g_value_set_pointer (value, priv->native);
			return;$^${isPossibleGlobal}
		case PROP_IS_GLOBAL_MEMORY:
			g_value_set_boolean (value, priv->is_global_memory);
			return;^$
	}

	G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
}

static void
${lowerSnake}_constructed (GObject *object)
{
	GObjectClass *parent_class = G_OBJECT_CLASS (${lowerSnake}_parent_class);
    
	if (parent_class->constructed != NULL)
		parent_class->constructed (object);
}

static void
${lowerSnake}_dispose (GObject *object)
{	
	G_OBJECT_CLASS (${lowerSnake}_parent_class)->dispose (object);
}

static void
${lowerSnake}_finalize (GObject *object)
{       
        $^!${isBare}if (${upperSnake} (object)->priv->owner == NULL$^${isPossibleGlobal} && 
                ${upperSnake} (object)->priv->is_global_memory == FALSE^$) {
                        ${destruction}
	} else {
		g_object_unref (${upperSnake} (object)->priv->owner);
	}^$$^${isBare}g_free (${upperSnake} (object)->priv->native);^$

	/* Chain up to parent's method. */
	G_OBJECT_CLASS (${lowerSnake}_parent_class)->finalize (object);
}

static void
${lowerSnake}_class_init (${upperCamel}Class *klass)
{
	GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
	
	g_type_class_add_private (klass, sizeof (${upperCamel}));

	gobject_class->set_property = ${lowerSnake}_set_property;
	gobject_class->get_property = ${lowerSnake}_get_property;	
	gobject_class->constructed = ${lowerSnake}_constructed;
	gobject_class->dispose = ${lowerSnake}_dispose;
	gobject_class->finalize = ${lowerSnake}_finalize;
        $^!${isBare}
	/**
	 * ${upperCamel}:owner:
	 *
	 * Owner of the native libical structure. If set, then it is
	 * responsible for a free of the native libical structure.
	 **/
        g_object_class_install_property (
		gobject_class,
		PROP_OWNER,
		g_param_spec_object (
			"owner",
			"Owner",
			"The native libical structure owner",
			G_TYPE_OBJECT,
			G_PARAM_READWRITE |
			G_PARAM_STATIC_STRINGS));^$
        
	/**
	 * ${upperCamel}:native:
	 *
	 * The native libical structure for this ICalObject.
	 **/
        g_object_class_install_property (
		gobject_class,
		PROP_NATIVE,
		g_param_spec_pointer (
			"native",
			"Native",
			"Native libical structure",
			G_PARAM_READWRITE |
			G_PARAM_CONSTRUCT_ONLY |
			G_PARAM_STATIC_STRINGS));$^${isPossibleGlobal}

	/**
	 * ${upperCamel}:is-global-memory:
	 *
	 * Whether the native libical structure is from a global shared memory.
	 * If #TRUE, then it is not freed on #${upperCamel}'s finalize.
	 **/
        g_object_class_install_property (
		gobject_class,
		PROP_IS_GLOBAL_MEMORY,
		g_param_spec_boolean (
			"is-global-memory",
			"Is-Global-Memory",
			"Whether the native libical structure is from a global shared memory",
			FALSE,
			G_PARAM_READWRITE |
			G_PARAM_CONSTRUCT_ONLY |
			G_PARAM_STATIC_STRINGS));^$
}

static void
${lowerSnake}_init (${upperCamel} *self)
{
	self->priv = G_TYPE_INSTANCE_GET_PRIVATE (self, ${upperSnake}_TYPE, ${upperCamel}Private);
}

/**
 * ${lowerSnake}_new_full: (skip)
 **/
${new_full}
{
        ${native} *nativeValue;$^${isBare}
        nativeValue = g_new (${native}, 1);
        *nativeValue = native;^$$^!${isBare}
        nativeValue = native;^$
        if (nativeValue == NULL)
                return NULL;

	return g_object_new (${upperSnake}_TYPE,$^!${isBare}
			     "owner", owner,^$
			     "native", nativeValue, $^${isPossibleGlobal}
                             "is-global-memory", is_global_memory,^$
			     NULL);
}

/**
 * ${lowerSnake}_get_native_set_owner: (skip)
 **/
${get_native_set_owner}
{
	${native} $^!${isBare}*^$defaultValue$^!${isBare} = NULL^$;
	g_return_val_if_fail (${namespaceLowerSnake}_IS_${nameLowerSnake}(object) && object != NULL, defaultValue);$^!${isBare}

        ${lowerSnake}_set_owner (object, owner);^$

	return $^${isBare}*(^$object->priv->native$^${isBare})^$;
}$^${isBare}

/**
 * ${lowerSnake}_get_native_pointer_set_owner: (skip)
 **/
${get_native_pointer_set_owner}
{
	${native} *defaultValue = NULL;
	g_return_val_if_fail (${namespaceLowerSnake}_IS_${nameLowerSnake}(object) && object != NULL, defaultValue);$^!${isBare}

	${lowerSnake}_set_owner (object, owner);^$

	return object->priv->native;
}^$

/**
 * ${lowerSnake}_get_native_remove_owner: (skip)
 **/
${native} $^!${isBare}*^$
${lowerSnake}_get_native_remove_owner (${upperCamel} *object)
{
	${native} $^!${isBare}*^$defaultValue$^!${isBare} = NULL^$;
	g_return_val_if_fail (${namespaceLowerSnake}_IS_${nameLowerSnake}(object) && object != NULL, defaultValue);$^!${isBare}

        g_object_unref (object->priv->owner);
	object->priv->owner = NULL;^$

	return $^${isBare}*(^$object->priv->native$^${isBare})^$;
}

/**
 * ${lowerSnake}_steal_native: (skip)
 **/
${native} $^!${isBare}*^$
${lowerSnake}_steal_native (${upperCamel} *object)
{
	${native} $^!${isBare}*^$defaultValue;
        ${native} $^!${isBare}*^$native;$^!${isBare}
        defaultValue = NULL;^$
	g_return_val_if_fail (${namespaceLowerSnake}_IS_${nameLowerSnake}(object) && object != NULL, defaultValue);

	native = $^${isBare}*(^$object->priv->native$^${isBare})^$;
	$^!${isBare}object->priv->native = NULL;^$$^${isBare}g_free (object->priv->native);^$

        return native;
}
